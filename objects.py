""" The classes containing the fields generated. """

from scipy.integrate import quad
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
from matplotlib.ticker import StrMethodFormatter
from abc import ABC
from postEoR.tools import hi_from_halos_2
from postEoR.tools import hlittle, OMm, OMl, c
from matplotlib.ticker import AutoLocator
from hmf import MassFunction
plt.rcParams.update({'font.size': 15})


class Base(ABC):
    """
    Abstract class used to access various functions applicable across both objects.
    """

    def get_distance(self) -> float:
        """
        Calculates line of sight distance covered by the lightcone, in units of Mpc. Assumes a flat ΛCDM cosmology.

        Returns
        -------
        dist : float
            The distance corresponding to the input redshift interval, in Mpc.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> cone = gen.generate_cone(4, 0.5, HII_dim=50)
        >>> print(box.get_distance())
        353.49355143881206
        """
        z_end = self.z_end
        z_start = self.z_start
        H_0 = hlittle * 100
        c_km = c / 1000
        dx = lambda z: 1 / (H_0*(OMm*(1+z)**3+OMl)**0.5)
        dist = quad(dx, z_end, z_start)
        dist = dist[0] * c_km

        return dist
    

    def gen_hmf(
        self, 
        set_bins=True,
        color="tab:blue", 
        linestyle="-", 
        title="Halo mass function", 
        save_loc="hmf.png", 
        save_fig=True,
        clear_prev_plot=False,
        Mmin=9,
        Mmax=12,
    ):
        """
        Generates a halo mass function at a given redshift. Used for testing of the halo finder.

        Parameters
        ----------
        set_bins : bool (optional)
            Whether to use the set bins (instead of the bins generated by np.histogram). Default is True.
        color : str (optional)
            The desired color of the plot. Defaults to "tab:blue".
        linestyle : str (optional)
            The desired linestyle of the plot. Defaults to "-".
        title : str (optional)
            The title of the output plot. Defaults to "Halo mass function".
        save_loc : str (optional)
            The path to the save location of the output plot. Defaults to hmf.png in the working directory.
        save_fig : bool (optional)
            Whether or not to automatically save the plot. Defaults to True.

        Returns
        -------
        bins : NDarray
            The mass bins used to create the HMF.
        counts : NDarray
            The number of halos falling in each halo mass bin.
        los_dist : float
            The physical distance corresponding to the redshift interval the lightcone is generated over, used for some plots.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> bins, counts, los_dist = box.gen_hmf(color="tab:orange")
        """
        if set_bins:
            bins1 = np.geomspace(10**Mmin, 10**Mmax, 10)
            counts, bins = np.histogram(self.halo_field, bins1)
        else:
            counts, bins = np.histogram(self.halo_field)

        if hasattr(self, "Lightconer"):
            los_dist = self.get_distance() # used for plotting
        else:
            los_dist = self.box_len
        
        if save_fig:
            if clear_prev_plot:
                plt.clf() # clearing any previous plots
            plt.rcParams['figure.figsize'] = [9, 6]
            bins_plot = (bins[1:] + bins[:-1]) / 2
            plt.hist(bins_plot, bins, weights=(2 * counts / (np.log(bins[1:]+bins[:-1])*self.box_len**2*los_dist)), histtype='step', label='z = ' + str(self.z), color=str(color))
            mf1 = MassFunction(Mmin=Mmin, Mmax=Mmax, z = self.z,
                        cosmo_params={"Om0":OMm}, 
                        hmf_model="Watson") 
            
            plt.plot(mf1.m * hlittle,mf1.dndm * mf1.m, label="z = " + str(self.z), linestyle=str(linestyle), color=str(color))
            plt.title(title)
            plt.yscale("log")
            plt.xscale("log")
            plt.legend()
            plt.ylabel('$\dfrac{dn}{d\log M}$ (Mpc$^{-3}$)')
            plt.xlabel('M (M$_{\odot}$)')
            plt.xlim(10**Mmin, 10**Mmax)

            plt.savefig(str(save_loc))

        return bins, counts, los_dist
    

    def gen_himf(
        self, 
        set_bins=True,
        color="tab:blue", 
        linestyle="-", 
        title="HI mass function", 
        save_loc="himf.png", 
        save_fig=True,
        clear_prev_plot=False,
    ):
        """
        Generates a HI mass function at a given redshift. Used for testing of the halo finder and HI-halo mass relation.

        Parameters
        ----------
        set_bins : bool (optional)
            Whether to use the set bins (instead of the bins generated by np.histogram). Default is True.
        color : str (optional)
            The desired color of the plot. Defaults to "tab:blue".
        linestyle : str (optional)
            The desired linestyle of the plot. Defaults to "-".
        title : str (optional)
            The title of the output plot. Defaults to "HI mass function".
        save_loc : str (optional)
            The path to the save location of the output plot. Defaults to himf.png in the working directory.
        save_fig : bool (optional)
            Whether or not to automatically save the plot. Defaults to True.

        Returns
        -------
        bins : NDarray
            The mass bins used to create the HIMF.
        counts : NDarray
            The number of halos falling in each HI mass bin.
        los_dist : float
            The physical distance corresponding to the redshift interval the lightcone is generated over, used for some plots.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> bins, counts, los_dist = box.gen_himf(color="tab:orange")
        """
        HI_field = hi_from_halos_2(self.halo_field, self.z)

        if set_bins:
            bins1 = np.geomspace(1e+6, 1e+9, 10)
            counts, bins = np.histogram(HI_field, bins1)
        else:
            counts, bins = np.histogram(HI_field)

        if self.hasattr("Lightconer"):
            los_dist = self.get_distance() # used for plotting

        if save_fig:
            if clear_prev_plot:
                plt.clf() # clearing any previous plots
            plt.rcParams['figure.figsize'] = [9, 6]
            bins_plot = (bins[1:] + bins[:-1]) / 2
            plt.hist(bins_plot, bins, weights=(2 * counts / (np.log(bins[1:]+bins[:-1])*self.box_len**2*los_dist)), histtype='step', label='z = ' + str(self.z), color=str(color))
            mf1 = MassFunction(z = self.z,
                        cosmo_params={"Om0":OMm}, 
                        hmf_model="Watson") 
            
            plt.plot(mf1.m * hlittle,mf1.dndm * mf1.m, label="z = " + str(self.z), linestyle=str(linestyle), color=str(color))
            plt.title(title)
            plt.yscale("log")
            plt.xscale("log")
            plt.ylabel('$\dfrac{dn}{d\log M}$ (Mpc$^{-3}$)')
            plt.xlabel('M (M$_{\odot}$)')
            plt.legend()

            plt.savefig(str(save_loc))

        return bins, counts, los_dist


    def get_PS(
        self, 
        field="BT", 
        kbins=None, 
        remove_nan=True, 
        color="tab:blue", 
        linestyle="-", 
        title="Power spectrum", 
        save_loc="ps.png", 
        save_fig=True,
        clear_prev_plot=False,
    ): 
        """
        Calculates the spherical power spectrum for the input field x. Can also automatically save the figure.

        Parameters
        ----------
        field : str (optional)
            The field whose power spectrum is to be calculated. Valid options are "BT", "dens", and "halo". Defaults to brightness temperature.
        kbins : NDarray (optional)
            The wavenumber bins to use in binning the power. If none / invalid bins are provided, bins will be generated automatically based on the minimum and maximum wavenumber and the number of cells in each dimension.
        remove_nan : bool (optional)
            Whether to remove NaN values from the binned power spectrum (need to keep if calculating the ratio between two power spectra). Defaults to True.
        color : str (optional)
            The desired color of the plot. Defaults to "tab:blue".
        linestyle : str (optional)
            The desired linestyle of the plot. Defaults to "-".
        title : str (optional)
            The title of the output plot. Defaults to "Power spectrum".
        save_loc : str (optional)
            The path to the save location of the output plot. Defaults to ps.png in the working directory.
        save_fig : bool (optional)
            Whether or not to automatically save the plot. Defaults to True.

        Returns
        -------
        new_k : NDarray
            The wavenumbers corresponding to the power spectrum.
        plot1 : NDarray
            The power spectrum of the input field x.
        error1 : NDarray
            The error in each bin of the power spectrum.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> k, ps, err = box.get_ps(field="BT", linestyle="--", save_fig=False)
        """
        if field == "BT":
            x = self.BT_field
        elif field == "dens":
            x = self.density_field
        elif field == "halo":
            x = self.halo_field
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
        box_len = self.box_len
        HII_dim = self.HII_dim
    
        n = np.size(x)
        dims = np.shape(x)

        # obtaining k values and k bins to use in ps
        ksx = np.fft.fftfreq(dims[0], self.cell_size) * 2 * np.pi # max accessible wavenumber corresponds to 2 * pi
        ksy = np.fft.fftfreq(dims[1], self.cell_size) * 2 * np.pi
        ksz = np.fft.fftfreq(dims[2], self.cell_size) * 2 * np.pi
        kx, ky, kz = np.meshgrid(ksx, ksy, ksz) # converting to a 3d array
        k = (kx**2+ky**2+kz**2)**0.5 # spherical k-values
        k = k.reshape(np.size(k)) # converting to 1d array for use in binned_statistic

        try: # check for input bins, and generate if none / invalid provided
            if kbins is None:
                kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1) # sampling in log space - defining bin edges
                print("Generated bins.")
            else:
                print("Using input bins")
        except AttributeError:
            print("Incorrect bin type. Generating bins")
            kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1)

        kvals = ((kbins[1:] + kbins[:-1])) / 2
        power1 = np.abs(np.fft.fftn(x))**2 # computing fft of field and taking absolute squared values
        ps1 = power1.reshape(np.size(power1)) / (n * (2 * np.pi * HII_dim / box_len)) # converting to 1d array | normalise by sampling volume

        bin_count1, _, _ = stats.binned_statistic(k, ps1, statistic="count", bins=kbins) # obtaining number of data points in each bin
        Abins1, _, _ = stats.binned_statistic(k, ps1, statistic = "mean", bins = kbins) # binning power
        error1, _, _ = stats.binned_statistic(k, ps1, statistic = "std", bins = kbins) # obtaining standard deviation in each bin

        new_k = np.array([x for x in kvals if x <= (2*np.pi / (2*self.cell_size))]) # removing values above the nyquist frequency (corresponds to sampling inside the cells)
        plot1 = Abins1[0:(np.size(new_k))]
        error1 = error1[0:(np.size(new_k))] / (bin_count1[0:(np.size(new_k))])**0.5

        if remove_nan:
            new_k = new_k[~np.isnan(plot1)]
            error1 = error1[~np.isnan(plot1)]
            plot1 = plot1[~np.isnan(plot1)]

        if save_fig:
            if clear_prev_plot:
                plt.clf() # clearing any previous plots
            plt.rcParams['figure.figsize'] = [9, 6]
            plt.plot(new_k, plot1, color=str(color), label="z = " + str(self.z) + ", " + str(field), linestyle=str(linestyle))

            plt.yscale("log")
            plt.xscale("log")
            plt.ylabel("P(k), (mK)$^2$)")
            plt.xlabel("k, (Mpc)$^{-1}$)")
            plt.legend()
            plt.title(title)

            plt.savefig(str(save_loc))

        return new_k, plot1, error1


    def get_dimless_PS(
        self, 
        field="BT", 
        kbins=None, 
        remove_nan=True,
        color="tab:blue", 
        linestyle="-", 
        title="Dimensionless power spectrum", 
        save_loc="dimless_ps.png", 
        save_fig=True,
        clear_prev_plot=False,
    ): 
        """
        Calculates the dimensionless spherical power spectrum for the input field x. 

        Parameters
        ----------
        field : str (optional)
            The field whose power spectrum is to be calculated. Valid options are "BT", "dens", and "halo". Defaults to brightness temperature.
        kbins : NDarray (optional)
            The wavenumber bins to use in binning the power. If none / invalid bins are provided, bins will be generated automatically based on the minimum and maximum wavenumber and the number of cells in each dimension.
        remove_nan : bool (optional)
            Whether to remove NaN values from the binned power spectrum (need to keep if calculating the ratio between two power spectra). Defaults to True.
        color : str (optional)
            The desired color of the plot. Defaults to "tab:blue".
        linestyle : str (optional)
            The desired linestyle of the plot. Defaults to "-".
        title : str (optional)
            The title of the output plot. Defaults to "Dimensionless power spectrum".
        save_loc : str (optional)
            The path to the save location of the output plot. Defaults to dimless_ps.png in the working directory.
        save_fig : bool (optional)
            Whether or not to automatically save the plot. Defaults to True.

        Returns
        -------
        new_k : NDarray
            The wavenumbers corresponding to the dimensionless power spectrum.
        plot1 : NDarray
            The dimensionless power spectrum of the input field x.
        error1 : NDarray
            The error in each bin of the dimensionless power spectrum.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> k, ps, err = box.get_dimless_ps(field="BT", linestyle="--", save_fig=False)
        """
        if field == "BT":
            x = self.BT_field
        elif field == "dens":
            x = self.density_field
        elif field == "halo":
            x = self.halo_field
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
        box_len = self.box_len
        HII_dim = self.HII_dim
        n = np.size(x)
        dims = np.shape(x)

        # obtaining k values and k bins to use in ps
        ksx = np.fft.fftfreq(dims[0], (self.cell_size)) * 2 * np.pi # max accessible wavenumber corresponds to 2 * pi
        ksy = np.fft.fftfreq(dims[1], (self.cell_size)) * 2 * np.pi
        ksz = np.fft.fftfreq(dims[2], (self.cell_size)) * 2 * np.pi
        kx, ky, kz = np.meshgrid(ksx, ksy, ksz) # converting to a 3d array
        k = (kx**2+ky**2+kz**2)**0.5 # spherical k-values
        k = k.reshape(np.size(k)) # converting to 1d array for use in binned_statistic

        try: # check for input bins, and generate if none / invalid provided
            if kbins is None:
                kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1) # sampling in log space - defining bin edges
            else:
                print("Using input bins")
        except AttributeError:
            kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1)
        
        kvals = ((kbins[1:] + kbins[:-1])) / 2
        power1 = np.abs(np.fft.fftn(x))**2 # computing fft of field and taking absolute squared values
        ps1 = power1.reshape(np.size(power1)) / (n * (2 * np.pi * HII_dim / box_len)) # converting to 1d array | normalise by sampling volume

        bin_count1, _, _ = (stats.binned_statistic(k, ps1, statistic="count", bins=kbins)) # obtaining number of data points in each bin
        Abins1, _, _ = stats.binned_statistic(k, ps1, statistic = "mean", bins = kbins) # binning power
        error1, _, _ = stats.binned_statistic(k, ps1, statistic = "std", bins = kbins) # obtaining standard deviation in each bin

        new_k = np.array([x for x in kvals if x <= (2*np.pi / (2*self.cell_size))]) # removing values above the nyquist frequency (corresponds to sampling inside the cells)
        plot1 = Abins1[0:(np.size(new_k))] 
        error1 = error1[0:(np.size(new_k))] / (bin_count1[0:(np.size(new_k))])**0.5 

        if remove_nan:
            new_k = new_k[~np.isnan(plot1)]
            error1 = error1[~np.isnan(plot1)] 
            plot1 = plot1[~np.isnan(plot1)]
        
        plot1 *= new_k**3 / (2 * np.pi**2) 
        error1 *= new_k**3 / (2 * np.pi**2) 

        if save_fig:
            if clear_prev_plot:
                plt.clf() # clearing any previous plots
            plt.rcParams['figure.figsize'] = [9, 6]
            plt.plot(new_k, plot1, color=str(color), label="z = " + str(self.z) + ", " + str(field), linestyle=str(linestyle))

            plt.yscale("log")
            plt.xscale("log")
            plt.ylabel("P(k), (mK)$^2$)")
            plt.xlabel("k, (Mpc)$^{-1}$)")
            plt.legend()
            plt.title(title)

            plt.savefig(str(save_loc))

        return new_k, plot1, error1
    

    def plot_slice(
        self,
        field="BT",
        save_loc="colormap.png",
        **kwargs,
    ):
        """
        Plot and save colormaps of a slice of the field, for the overdensity and either the brightness temperature or the halo field.

        Parameters
        ----------
        field : str (optional)
            The field to be plotted alongside the overdensity. Defaults to brightness temperature. Valid options are "BT" or "halo".
        save_loc : str (optional)
            The path and filename for the plot to be saved to. Defaults to colormap.png in the working directory.
        **kwargs : str (optional)
            Additional colormap plotting specifications.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> box.plot_slice(field="halo", vmax=1e12)
        """
        plt.clf() # clearing any previous plots
        plt.rcParams['figure.figsize'] = [13, 6]
        fig, (ax1, ax3) = plt.subplots(1,2)

        if field == "BT":
            x = self.BT_field
        elif field == "halo":
            x = self.halo_field
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\" and \"halo\".")
            x = self.BT_field

        # box coordinates
        fin_size = np.shape(x)[0] / self.HII_dim * self.box_len
        dx, dy = self.cell_size, self.cell_size 
        y1, x1 = np.mgrid[slice(dy / 2, fin_size, dy), slice(dx / 2, fin_size, dx)]

        # plotting colormaps of overdensity, neutral fraction, brightness temperature
        cb1 = ax1.pcolormesh(x1, y1, self.density_field[:, :, 10], cmap = "viridis")
        ax1.set_xlabel('$x$ (Mpc)')
        ax1.set_ylabel('$y$ (Mpc)')
        cbar1 = fig.colorbar(cb1)
        cbar1.set_label('Overdensity', rotation=270, labelpad = 12)

        cb3 = ax3.pcolormesh(x1, y1, x[:, :, 10], cmap = "viridis", **kwargs)
        ax3.set_xlabel('$x$ (Mpc)')
        cbar3 = fig.colorbar(cb3)
        cbar3.set_label(str(field), rotation=270, labelpad = 12)
        cbar3.formatter.set_powerlimits((0, 0))

        fig.suptitle("HII_dim " + str(self.HII_dim) + ", box_len " + str(self.box_len) + ",  z = " + str(self.z))
        fig.tight_layout()

        plt.savefig(str(save_loc))


    def gen_k_bins(self):
        """
        Used to generate k bins for use in comparative power spectra / bias calculations.

        Returns
        -------
        kbins_def : NDarray
            The k bins derived from the distance scales involved in the object.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> box.gen_k_bins()
        """
        dens = self.density_field
        dims = np.shape(dens)

        # obtaining k values and k bins to use in ps
        ksx = np.fft.fftfreq(dims[0], (self.cell_size)) * 2 * np.pi # max accessible wavenumber corresponds to 2 * pi
        ksy = np.fft.fftfreq(dims[1], (self.cell_size)) * 2 * np.pi
        ksz = np.fft.fftfreq(dims[2], (self.cell_size)) * 2 * np.pi
        kx, ky, kz = np.meshgrid(ksx, ksy, ksz) # converting to a 3d array
        k = (kx**2+ky**2+kz**2)**0.5 # spherical k-values
        k = k.reshape(np.size(k)) # converting to 1d array for use in binned_statistic

        kbins_def = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), self.HII_dim//2+1)

        return kbins_def


    def get_bias(self):
        """
        Generates the HI bias as a function of wavenumber for the object.

        Returns
        -------
        k1 : NDarray
            The wavenumber values corresponding to each of the bias values.
        HI_bias : NDarray
            The HI bias across the scales of the object.
        
        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> box = gen.generate_box(z=4)
        >>> k, bias = box.get_bias()
        """
        bins = self.gen_k_bins()

        k1, ps1, _ = self.get_PS("BT", remove_nan=False, kbins=bins, save_fig=False)
        _, ps2, _ = self.get_PS("dens", remove_nan=False, kbins=bins, save_fig=False)
        HI_bias = (ps1 / ps2)**0.5

        k1 = k1[~np.isnan(HI_bias)]
        HI_bias = HI_bias[~np.isnan(HI_bias)]

        return k1, HI_bias





class Ltcone(Base):
    """
    The lightcone object, containing all of its defining information and fields.

    Parameters
    ----------
    z_start : float
        The maximum redshift of the lightcone.
    z_end : float
        The minimum redshift of the lightcone.
    box_len : float
        The length in Mpc of the lightcone along its spatial dimensions.
    HII_dim : float
        The number of cells along the spatial dimensions of the lightcone.
    density_field : NDarray
        The overdensity field of the lightcone, calculated using 21cmFAST. Dimensionless.
    halo_field: NDarray
        The halo field of the lightcone, in solar masses.
    BT_field : NDarray
        The brightness temperature field of the lightcone, in mK.
    Lightconer : Lightconer object
        The lightcone class object output by 21cmFAST.
    """
    def __init__(
        self, 
        z_start : float, 
        z_end : float, 
        box_len : float, 
        HII_dim : int, 
        density_field : np.ndarray, 
        halo_field : np.ndarray, 
        BT_field : np.ndarray, 
        Lightconer,
    ):
        self.z_start = z_start
        self.z_end = z_end
        self.box_len = box_len
        self.HII_dim = HII_dim
        self.density_field = density_field
        self.halo_field = halo_field
        self.BT_field = BT_field
        self.Lightconer = Lightconer
        self.z = (z_start + z_end) / 2
        self.cell_size = box_len / HII_dim


    def plot_lightcone(
        self,
        save_loc="lightcone.png",
        title="Lightcone",
        field="BT",
        **kwargs
    ):
        """
        Plot and save the redshift evolution of a given quantity of the lightcone (e.g. brightness temperature, density).
        Adapted from 21cmFAST lightcone plotting function.

        Parameters
        ----------
        save_loc : str (optional)
            The path and filename for the plot to be saved to. Defaults to lightcone.png in the working directory.
        title : str (optional)
            The title of the plot. Defaults to "Lightcone"
        field : str (optional)
            The field to be plotted. Valid options are "BT", "dens", and "halo". Defaults to BT.
        **kwargs : str (optional)
            Additional colormap plotting specifications.

        Example usage
        -------------
        >>> from postEoR import generation as gen
        >>> cone = gen.generate_cone(z_centr=4, delta_z=1)
        >>> cone.plot_lightcone(save_loc="cone.png", field="dens", vmax=10)
        """
        fig, ax = plt.subplots(1,1, constrained_layout=True)

        lightcone = self.Lightconer

        if field == "BT":
            x = self.BT_field
            label = "Brightness temperature, mK"
        elif field == "dens":
            x = self.density_field
            label = "Overdensity"
        elif field == "halo":
            x = self.halo_field
            label = "Halo mass, M$_{\odot}$"
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
            label = "Brightness temperature, mK"
        
        extent = (0, lightcone.lightcone_dimensions[2], 0, lightcone.lightcone_dimensions[[1, 0, 1][0]])

        plot = ax.imshow(x[:, 10, :], extent=extent, **kwargs)
        cbar = fig.colorbar(plot, ax=ax)
        cbar.set_label(str(label), rotation=270, labelpad = 12)

        fig.gca().xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))

        loc = AutoLocator()
        coords = lightcone.lightcone_redshifts
        units = getattr(coords, "unit", None)
        if units:
            zlabel += f" [{str(coords.unit)}]"
            coords = coords.value

        ticks = loc.tick_values(coords.min(), coords.max())

        if ticks.min() < coords.min() / 1.00001:
            ticks = ticks[1:]
        if ticks.max() > coords.max() * 1.00001:
            ticks = ticks[:-1]

        if coords[1] < coords[0]:
            ticks = ticks[::-1]

        d_ticks = (
            lightcone.cosmo_params.cosmo.comoving_distance(ticks).value
            - lightcone.lightcone_distances[0].value
        )
        getattr(ax, f"set_xticks")(d_ticks)
        getattr(ax, f"set_xticklabels")(ticks)

        labels = [item.get_text() for item in ax.get_xticklabels()]
        ax.set_xticklabels([str(round(float(label), 1)) for label in labels if label != ''])
        ax.set_xlabel("Redshift")
        ax.set_ylabel("y (Mpc)")
        fig.suptitle(title)

        plt.savefig(str(save_loc))

    
    def get_cylindrical_ps(
        self,
        title="Cylindrical power spectrum",
        save_loc="cylindrical_ps.png",
        ):
        """
        Calculate and plot the cylindrical power spectrum of the lightcone. NEEDS FURTHER TESTING

        Parameters
        ----------
        title : str (optional)
            The title of the output plot. Defaults to "Cylindrical power spectrum".
        save_loc : str (optional)
            The path to the save location of the output plot. Defaults to cylindrical_ps.png in the working directory.
        """
        BT = self.BT_field
        power0 = np.zeros(np.shape(BT)[:-1])
        power2 = np.zeros(np.shape(BT)[2])

        # taking the mean of all the individual perp and parallel ps
        for i in range(np.shape(BT)[0]):
            for j in range(np.shape(BT)[1]):
                power2 += np.abs(np.fft.fft(BT[i, j, :]))**2
        for i in range(np.shape(BT)[2]):
            power0 += np.abs(np.fft.fftn(BT[:, :, i]))**2
        power2 /= np.shape(BT)[0] * np.shape(BT)[1]
        power0 /= np.shape(BT)[2]

        n1 = np.size(power0)
        n2 = np.size(power2)
        dims1 = np.shape(BT)[0]
        dims2 = np.shape(BT)[2]

        para = power2.reshape(n2)
        perp = power0.reshape(n1) 

        # obtaining the corresponding wavenumbers
        ks1 = np.fft.fftfreq(dims1, (self.cell_size)) * 2 * np.pi
        kx, ky = np.meshgrid(ks1, ks1) # converting to a 2d array
        k1 = (kx**2+ky**2)**0.5 # perp k-values
        k1 = k1.reshape(np.size(k1)) # converting to 1d array for use in binned_statistic
        kbins1 = np.geomspace(np.min(k1[np.nonzero(k1)]), np.max(k1), dims1//16+1) # sampling in log space - defining bin edges
        kvals1 = ((kbins1[1:] + kbins1[:-1])) / 2
        k2 = np.abs(np.fft.fftfreq(dims2, np.abs(self.get_distance() / dims2)) * 2 * np.pi)
        kbins2 = np.geomspace(np.min(k2[np.nonzero(k2)]), np.max(k2), dims2//16+1) # sampling in log space - defining bin edges
        kvals2 = ((kbins2[1:] + kbins2[:-1])) / 2

        Abins1, _, _ = stats.binned_statistic(k1, perp, statistic = "mean", bins = kbins1)
        Abins2, _, _ = stats.binned_statistic(k2, para, statistic = "mean", bins = kbins2)

        # removing values past the nyquist frequency | normalising by the sampling volume
        new_k_1 = np.array([x for x in kvals1 if x <= (2*np.pi / (2*self.box_len / self.HII_dim))])
        new_k_2 = np.array([x for x in kvals2 if x <= (2*np.pi / (2* np.abs(self.get_distance()) / dims2))])
        plot1 = Abins1[0:(np.size(new_k_1))] / (np.max(new_k_1)**2 * np.pi * 4)
        plot2 = Abins2[0:(np.size(new_k_2))] / (np.max(new_k_2) * 2 * np.pi)

        # removing NaN values and adding a k=0 value for plotting
        new_k_1 = new_k_1[~np.isnan(plot1)]
        new_k_1 = np.insert(new_k_1, 0, np.min(k1[np.nonzero(k1)]))
        plot1 = plot1[~np.isnan(plot1)]
        new_k_2 = new_k_2[~np.isnan(plot2)]
        new_k_2 = np.insert(new_k_2, 0, np.min(k2[np.nonzero(k2)]))
        plot2 = plot2[~np.isnan(plot2)]
        new_k_2 = new_k_2[:-1]
        plot2 = plot2[:-1] # this truncation is just bc some weird sampling things were happening at the final wavenumber - think it was going inside the cell

        cross = np.zeros((np.size(plot2), np.size(plot1))) # calculating the cross power spectrum
        for i in range(np.size(plot1)):
            for j in range(np.size(plot2)):
                cross[j,i] = plot1[i] * plot2[j]

        cb = plt.pcolormesh(np.log(new_k_1),np.log(new_k_2), np.log(cross), cmap = "viridis")
        plt.xlabel("log(k$_{\perp}$, (Mpc)$^{-1}$)")
        plt.ylabel("log(k$_\|$, (Mpc)$^{-1}$)")
        cbar = plt.colorbar(cb)
        cbar.set_label("log(P$_{cross}$, (mK)$^2$)")
        plt.title(str(title))

        plt.savefig(str(save_loc))



class Box(Base):
    """
    The coeval box object, containing all of its defining information and fields.

    Parameters
    ----------
    z : float
        The redshift of the box.
    box_len : float
        The length in Mpc of the box dimensions.
    HII_dim : float
        The number of cells along the box dimensions.
    density_field : NDarray
        The overdensity field of the coeval box, calculated using 21cmFAST. Dimensionless.
    halo_field: NDarray
        The halo field of the coeval box, in solar masses.
    BT_field : NDarray
        The brightness temperature field of the coeval box, in mK.
        """
    def __init__(
        self, 
        z : float,
        box_len : float, 
        HII_dim : int, 
        density_field : np.ndarray, 
        halo_field : np.ndarray, 
        BT_field : np.ndarray, 
    ):
        self.z  = z
        self.box_len = box_len
        self.HII_dim = HII_dim
        self.density_field = density_field
        self.halo_field = halo_field
        self.BT_field = BT_field
        self.cell_size = box_len / HII_dim
