""" The classes containing the fields generated. """

from scipy.integrate import quad
from .constants import *
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
from matplotlib.ticker import StrMethodFormatter
from abc import ABC
from hmf import MassFunction
from .tools import hi_from_halos_2

class Base(ABC):
    """
    Abstract class used to access various functions applicable across both objects.
    """
    def cell_size(self) -> float:
        """
        Calculates cell size used in the lightcone in Mpc.
        """
        return self.box_len / self.HII_dim 
    

    def get_distance(self) -> float:
        """
        Calculates line of sight distance covered by the lightcone, in units of Mpc. Assumes a flat ΛCDM cosmology.

        Returns
        -------
        dist : float
            The distance corresponding to the input redshift interval, in Mpc.
        """
        z_end = self.z_end
        z_start = self.z_start
        c_km = c / 1000
        dx = lambda z: 1 / (H_0*(omega_m*(1+z)**3+omega_lambda)**0.5)
        dist = quad(dx, z_end, z_start)
        dist = dist[0] * c_km

        return dist
    

    def gen_hmf(self, set_bins=True):
        """
        Generates a halo mass function at a given redshift. Used for testing of the halo finder.

        Parameters
        ----------
        set_bins : bool (optional)
            Whether to use the set bins (instead of the bins generated by np.histogram). Default is True.

        Returns
        -------
        bins : NumPy array
            The mass bins used to create the HMF.
        counts : NumPy array
            The number of halos falling in each halo mass bin.
        los_dist : float
            The physical distance corresponding to the redshift interval the lightcone is generated over, used for some plots.
        """
        if set_bins:
            bins1 = np.geomspace(1e+10, 1e+13, 10)
            counts, bins = np.histogram(self.halo_field, bins1)
        else:
            counts, bins = np.histogram(self.halo_field)

        if self.hasattr("Lightconer"):
            los_dist = self.get_distance(self.z_start, self.z_end) # used for plotting

        return bins, counts, los_dist
    

    def gen_himf(self, set_bins=True):
        """
        Generates a HI mass function at a given redshift. Used for testing of the halo finder and HI-halo mass relation.

        Parameters
        ----------
        set_bins : bool (optional)
            Whether to use the set bins (instead of the bins generated by np.histogram). Default is True.

        Returns
        -------
        bins : NumPy array
            The mass bins used to create the HIMF.
        counts : NumPy array
            The number of halos falling in each HI mass bin.
        los_dist : float
            The physical distance corresponding to the redshift interval the lightcone is generated over, used for some plots.
        """
        HI_field = hi_from_halos_2(self.halo_field, self.z)

        if set_bins:
            bins1 = np.geomspace(1e+10, 1e+13, 10)
            counts, bins = np.histogram(HI_field, bins1)
        else:
            counts, bins = np.histogram(HI_field)

        if self.hasattr("Lightconer"):
            los_dist = self.get_distance(self.z_start, self.z_end) # used for plotting

        return bins, counts, los_dist


    def get_PS(self, field="BT", kbins=np.asarray([np.nan, np.nan]), remove_nan=True): 
        """
        Calculates the power spectrum for the input field x.

        Parameters
        ----------
        field : str (optional)
            The field whose power spectrum is to be calculated. Valid options are "BT", "dens", and "halo". Defaults to brightness temperature.
        kbins : NumPy array (optional)
            The wavenumber bins to use in binning the power. If none / invalid bins are provided, bins will be generated automatically based on the minimum and maximum wavenumber and the number of cells in each dimension.
        remove_nan : bool (optional)
            Whether to remove NaN values from the binned power spectrum (need to keep if calculating the ratio between two power spectra). Defaults to True.

        Returns
        -------
        new_k : NumPy array
            The wavenumbers corresponding to the power spectrum.
        plot1 : NumPy array
            The power spectrum of the input field x.
        error1 : NumPy array
            The error in each bin of the power spectrum.
        """
        if field == "BT":
            x = self.BT_field
        elif field == "dens":
            x = self.density_field
        elif field == "halo":
            x = self.halo_field
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
        box_len = self.box_len
        HII_dim = self.HII_dim
    
        n = np.size(x)
        dims = np.shape(x)

        # obtaining k values and k bins to use in ps
        ksx = np.fft.fftfreq(dims[0], (box_len / HII_dim)) * 2 * np.pi # max accessible wavenumber corresponds to 2 * pi
        ksy = np.fft.fftfreq(dims[1], (box_len / HII_dim)) * 2 * np.pi
        ksz = np.fft.fftfreq(dims[2], (box_len / HII_dim)) * 2 * np.pi
        kx, ky, kz = np.meshgrid(ksx, ksy, ksz) # converting to a 3d array
        k = (kx**2+ky**2+kz**2)**0.5 # spherical k-values
        k = k.reshape(np.size(k)) # converting to 1d array for use in binned_statistic

        try: # check for input bins, and generate if none / invalid provided
            if np.isnan(kbins.any()):
                kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1) # sampling in log space - defining bin edges
            else:
                print("Using input bins")
        except AttributeError:
            print("Incorrect bin type. Generating bins")
            kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1)

        kvals = ((kbins[1:] + kbins[:-1])) / 2
        power1 = np.abs(np.fft.fftn(x))**2 # computing fft of field and taking absolute squared values
        ps1 = power1.reshape(np.size(power1)) / (n * (2 * np.pi * HII_dim / box_len)) # converting to 1d array | normalise by sampling volume

        bin_count1, _, _ = stats.binned_statistic(k, ps1, statistic="count", bins=kbins) # obtaining number of data points in each bin
        Abins1, _, _ = stats.binned_statistic(k, ps1, statistic = "mean", bins = kbins) # binning power
        error1, _, _ = stats.binned_statistic(k, ps1, statistic = "std", bins = kbins) # obtaining standard deviation in each bin

        new_k = np.array([x for x in kvals if x <= (2*np.pi / (2*box_len / HII_dim))]) # removing values above the nyquist frequency (corresponds to sampling inside the cells)
        plot1 = Abins1[0:(np.size(new_k))]
        error1 = error1[0:(np.size(new_k))] / (bin_count1[0:(np.size(new_k))])**0.5

        if remove_nan:
            new_k = new_k[~np.isnan(plot1)]
            error1 = error1[~np.isnan(plot1)]
            plot1 = plot1[~np.isnan(plot1)]

        return new_k, plot1, error1


    def get_dimless_PS(self, field="BT", kbins=np.asarray([np.nan, np.nan]), remove_nan=True): 
        """
        Calculates the dimensionless power spectrum for the input field x.

        Parameters
        ----------
        field : str (optional)
            The field whose power spectrum is to be calculated. Valid options are "BT", "dens", and "halo". Defaults to brightness temperature.
        kbins : NumPy array (optional)
            The wavenumber bins to use in binning the power. If none / invalid bins are provided, bins will be generated automatically based on the minimum and maximum wavenumber and the number of cells in each dimension.
        remove_nan : bool (optional)
            Whether to remove NaN values from the binned power spectrum (need to keep if calculating the ratio between two power spectra). Defaults to True.

        Returns
        -------
        new_k : NumPy array
            The wavenumbers corresponding to the dimensionless power spectrum.
        plot1 : NumPy array
            The dimensionless power spectrum of the input field x.
        error1 : NumPy array
            The error in each bin of the dimensionless power spectrum.
        """
        if field == "BT":
            x = self.BT_field
        elif field == "dens":
            x = self.density_field
        elif field == "halo":
            x = self.halo_field
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
        box_len = self.box_len
        HII_dim = self.HII_dim
        n = np.size(x)
        dims = np.shape(x)

        # obtaining k values and k bins to use in ps
        ksx = np.fft.fftfreq(dims[0], (box_len / HII_dim)) * 2 * np.pi # max accessible wavenumber corresponds to 2 * pi
        ksy = np.fft.fftfreq(dims[1], (box_len / HII_dim)) * 2 * np.pi
        ksz = np.fft.fftfreq(dims[2], (box_len / HII_dim)) * 2 * np.pi
        kx, ky, kz = np.meshgrid(ksx, ksy, ksz) # converting to a 3d array
        k = (kx**2+ky**2+kz**2)**0.5 # spherical k-values
        k = k.reshape(np.size(k)) # converting to 1d array for use in binned_statistic

        try: # check for input bins, and generate if none / invalid provided
            if np.isnan(kbins.any()):
                kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1) # sampling in log space - defining bin edges
            else:
                print("Using input bins")
        except AttributeError:
            kbins = np.geomspace(np.min(k[np.nonzero(k)]), np.max(k), HII_dim//2+1)
        
        kvals = ((kbins[1:] + kbins[:-1])) / 2
        power1 = np.abs(np.fft.fftn(x))**2 # computing fft of field and taking absolute squared values
        ps1 = power1.reshape(np.size(power1)) / (n * (2 * np.pi * HII_dim / box_len)) # converting to 1d array | normalise by sampling volume

        bin_count1, _, _ = (stats.binned_statistic(k, ps1, statistic="count", bins=kbins)) # obtaining number of data points in each bin
        Abins1, _, _ = stats.binned_statistic(k, ps1, statistic = "mean", bins = kbins) # binning power
        error1, _, _ = stats.binned_statistic(k, ps1, statistic = "std", bins = kbins) # obtaining standard deviation in each bin

        new_k = np.array([x for x in kvals if x <= (2*np.pi / (2*box_len / HII_dim))]) # removing values above the nyquist frequency (corresponds to sampling inside the cells)
        plot1 = Abins1[0:(np.size(new_k))] 
        error1 = error1[0:(np.size(new_k))] / (bin_count1[0:(np.size(new_k))])**0.5 

        if remove_nan:
            new_k = new_k[~np.isnan(plot1)]
            error1 = error1[~np.isnan(plot1)] 
            plot1 = plot1[~np.isnan(plot1)]
        
        plot1 *= new_k**3 / (2 * np.pi**2) 
        error1 *= new_k**3 / (2 * np.pi**2) 

        return new_k, plot1, error1



class Ltcone(Base):
    """
    The lightcone object, containing all of its defining information and fields.

    Parameters
    ----------
    z_start : float
        The maximum redshift of the lightcone.
    z_end : float
        The minimum redshift of the lightcone.
    box_len : float
        The length in Mpc of the lightcone along its spatial dimensions.
    HII_dim : float
        The number of cells along the spatial dimensions of the lightcone.
    density_field : NumPy array
        The overdensity field of the lightcone, calculated using 21cmFAST. Dimensionless.
    halo_field: NumPy array
        The halo field of the lightcone, in solar masses.
    BT_field : NumPy array
        The brightness temperature field of the lightcone, in mK.
    Lightconer : Lightconer object
        The lightcone class object output by 21cmFAST.
    """
    def __init__(
        self, 
        z_start : float, 
        z_end : float, 
        box_len : float, 
        HII_dim : int, 
        density_field : np.ndarray, 
        halo_field : np.ndarray, 
        BT_field : np.ndarray, 
        Lightconer,
    ):
        self.z_start = z_start
        self.z_end = z_end
        self.box_len = box_len
        self.HII_dim = HII_dim
        self.density_field = density_field
        self.halo_field = halo_field
        self.BT_field = BT_field
        self.Lightconer = Lightconer
        self.z = (z_start + z_end) / 2

    def plot_lightcone(
        self,
        save_loc : str,
        title : str,
        field="BT",
    ):
        """
        Plot and save the redshift evolution of a given quantity of the lightcone (e.g. brightness temperature, density).

        Parameters
        ----------
        save_loc : str
            The path and filename for the plot to be saved to.
        title : str
            The title of the plot.
        field : str (optional)
            The field to be plotted. Valid options are "BT", "dens", and "halo".
        """
        fig, ax = plt.subplots(1,1, constrained_layout=True)

        lightcone = self.Lightconer

        z_axis = "x"
        slice_axis = 0
        axis_dct = {
                "x": 2 if z_axis == "x" else [1, 0, 0][slice_axis],
                "y": 2 if z_axis == "y" else [1, 0, 1][slice_axis],
            }
        extent = (
                0,
                lightcone.lightcone_dimensions[axis_dct["x"]],
                0,
                lightcone.lightcone_dimensions[axis_dct["y"]],
            )

        if field == "BT":
            x = self.BT_field
            label = "Brightness temperature, mK"
        elif field == "dens":
            x = self.density_field
            label = "Overdensity"
        elif field == "halo":
            x = self.halo_field
            label = "Halo mass, M$_{\odot}$"
        else:
            print("Invalid field entered. Defaulting to brightness temperature. \n Valid field options are \"BT\", \"dens\", and \"halo\".")
            x = self.BT_field
            label = "Brightness temperature, mK"
            
        plot = ax.imshow(x[:, 10, :], extent=extent)
        cbar = fig.colorbar(plot, ax=ax)
        cbar.set_label(str(label), rotation=270, labelpad = 12)

        fig.gca().xaxis.set_major_formatter(StrMethodFormatter('{x:,.1f}'))

        labels = [item.get_text() for item in ax.get_xticklabels()]
        ax.set_xticklabels([str(round(float(label), 1)) for label in labels if label != ''])
        ax.set_xlabel("Redshift")
        ax.set_ylabel("y (Mpc)")
        fig.suptitle(title)

        plt.savefig(str(save_loc))



class Box(Base):
    """
    The coeval box object, containing all of its defining information and fields.

    Parameters
    ----------
    z : float
        The redshift of the box.
    box_len : float
        The length in Mpc of the box dimensions.
    HII_dim : float
        The number of cells along the box dimensions.
    density_field : NumPy array
        The overdensity field of the coeval box, calculated using 21cmFAST. Dimensionless.
    halo_field: NumPy array
        The halo field of the coeval box, in solar masses.
    BT_field : NumPy array
        The brightness temperature field of the coeval box, in mK.
        """
    def __init__(
        self, 
        z : float,
        box_len : float, 
        HII_dim : int, 
        density_field : np.ndarray, 
        halo_field : np.ndarray, 
        BT_field : np.ndarray, 
    ):
        self.z  = z
        self.box_len = box_len
        self.HII_dim = HII_dim
        self.density_field = density_field
        self.halo_field = halo_field
        self.BT_field = BT_field
